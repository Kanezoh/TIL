# 第2章　オブジェクトモデル

## 2.1 オープンクラス

例えば、こんなコードがあるとする。  
~~~
def to_alphanumeric(s)
  s.gsub(/[^\w\s]/,'')
end
~~~

これは文字列から全ての句読点や特殊文字を排除、アルファベットとスペースのみにするメソッド。  
全ての文字列で共通して使える距離ならStringクラスをオープンして、そのメソッドとして追加する方が良い。  

~~~
class String
  def to_alphanumeric
     gsub(/[^\w\s]/,'')
  end
end
~~~  

Rubyではクラス定義のコードと他のコードに違いはないため、クラス定義の中に好きなコードを配置できる。  
~~~
3.times do
  class A
    puts 'ababa'
  end
end
=> ababa
   ababa
   ababa
~~~  

この場合、クラスが3回作成されているわけではない。1回目にクラスが作成され、それ以降はクラスを再オープンしてコードを実行している。  
Rubyにおけるclassはスコープ演算子のようなもの。存在しないクラスは作成、存在すれば再オープンしてとにかくそのクラスのコンテキストに連れて行ってくれる。  
だから既存のクラスにメソッドを追加したければ再オープンして定義すれば良いだけ、この手法を *オープンクラス* という。  

### 問題点

既存のクラスにメソッドを追加するときは注意が必要、例えばreplaceという名前のArrayクラスのメソッドがある。  
これを知らずに空の要素を削除するメソッドをreplaceというメソッドで追加したりすると...  
~~~
class Array
  def replace
    select{|e| e.empty?}
  end
end

arr = ['a','b','']
p arr.replace => ['a','b'] 
~~~  

なんと、標準メソッドをオーバーライドしていると警告が出ない。  
このように、オープンクラスだからと言って考えなしにメソッドを追加していては予期せぬバグを生んでしまう。  
このようなコードは *モンキーパッチ*(蔑称？）と呼ばれている。  

## 2.2 オブジェクトモデルの内部

### インスタンス変数

Java等とは違ってRubyのインスタンス変数にはクラスと何のつながりもない。その証拠に同じクラスから作成されたインスタンスでも
インスタンス変数が異なることもある。  
~~~
class A
  my_method
    @v = 1
  end
end

obj1 = A.new
obj1.my_method

obj2 = A.new

obj1.instance_variables => [:@v]
obj2.instance_variables => []
~~~  

インスタンス変数の名前、値はハッシュのキーと値のようなものだと覚えておこう。キーとバリューはどちらもオブジェクトによって
異なることがある。 

### メソッド

「共通のクラスを持つオブジェクトはメソッドも共通している。つまりメソッドはオブジェクトではなくクラスに存在する。」 

オブジェクトには自身が保有するインスタンス変数とクラスへの参照が存在するだけでメソッドは持っていない。メソッドはクラスに住んでいるからだ。  

### クラス

「クラスはオブジェクト」  

クラスはオブジェクトなのでクラスにもクラスがある、もちろんそれはClassクラスである。  
~~~
'ababa'.class => String
String.class =>Class
~~~

RubyのClassクラスのインスタンスは文字通りクラスそのものであるため、Class.newを使えば実行時にクラスに書き込みができたりする。  
また、クラスにもメソッドがある。上述のように、Classクラスに定義されているインスタンスメソッドだ。  
~~~
Class.instance_methods(false) =>[:allocate,:new,:superclass]
* 引数のfalseは「継承されたメソッドは無視する」の意
~~~  
superclassメソッドはそのクラスが継承しているクラスを教えてくれるメソッド。  
~~~
Array.superclass => Object
Object.superclass => BasicObject
BasicObject.superclass => nil
~~~  

このように、BasicObjectを頂点とした階層構造になっている。ではClassのスーパークラスはなんだろう？  

### モジュール

~~~
Class.superclass => Module
~~~

Classのスーパークラスはどうやらモジュールらしい。つまり、クラスはオブジェクトの生成、クラスの継承機能を備えたモジュールだったということだ。  
同じような機能のクラスとモジュールを分けるメリットは役割を明確にすることでコードをわかりやすくするためだ。  
- どこかでインクルードする→モジュール
- インスタンスの生成、継承がしたい→クラス  

### 定数

大文字で始まる参照はクラス名であれモジュール名であれ定数だ。警告は出るが定数の値の変更もできる。  
~~~
::Array = Ababa
arr = Ababa.new(4,'aba')
p arr =>['aba','aba','aba','aba']
~~~  

定数はネストできる。  
~~~ 
module A
  class C
    X = 'constant'
  end

  C::X => 'constant
end

M::C::X => 'constant'
~~~

ルートレベルにある定数はコロン２つで表すことができる。
~~~
::String
::Array
~~~  

イメージとしてはディレクトリ、ファイルのパスとかをイメージするといい。  

## ここまでのまとめ

オブジェクトとは？  
インスタンス変数の集まりにクラスへのリンクが付いたもの  

クラスとは？  
インスタンスメソッドの一覧とスーパークラスへのリンクが付いたもの  

## ネームスペース（名前空間）を使おう

ここまで見てきたように、クラス名やモジュール名はただの定数だ。しかし、気づかぬうちにそれが衝突してしまうことがある。  
使っているライブラリに同名のクラスがあったとか。そんな時に使えるのが　*ネームスペース* だ。  
先ほど定数はディレクトリのようなものだと言った。同じファイル名のファイルがあっても違うディレクトリにあれば問題はない。  
Rubyではモジュールを使って名前空間を作成してこれと同じようなことを行う。  
例えばTextという名前のクラスが衝突していれば  

~~~
module MyApp
  class Text
  end
end
~~~

のようにすれば良い。これで衝突していたTextとは別物となり、MyApp:Textで参照できるようになる。
まさか他のライブラリもMyAppモジュールの直下にText定数を配置していたなんてことはないだろう。

## 2.4 メソッド探索

Q.メソッド探索とは？  
A. メソッドが呼び出されたらRubyがレシーバのクラスに入り、メソッドが見つかるまで継承チェーンを上ること  

Q.モジュールがインクルードされてたらどうなる？  
A.モジュールが継承チェーンに挿入される  

~~~
module M1
  def my_method; end
end

class C
  include M1
end

class D < C; end

D.ancestors => [D,C,M1,Object,Kernel,BasicObject]
~~~

prependメソッドでも同様にモジュールを継承チェーンに挿入できるが、インクルードされたクラスの*下に*挿入される。  

### Kernel

どこでも呼び出せるメソッド（printなど）はObjectクラスがインクルードしているKernelモジュールのprivateインスタンスメソッド。  

### selfキーワード  

Rubyのコードはオブジェクト(カレントオブジェクト)の内部で実行される。そのカレントオブジェクトがself。  
メソッドを呼び出すとそのメソッドのレシーバがselfとなり、レシーバを指定しないメソッド呼び出しは全てselfに対する呼び出しになる。  
### main

メソッドを呼び出すとそのオブジェクトがselfになる、じゃあ呼び出さない状態ではselfは何になる？  
~~~
self => main
self.class => Object
~~~  

*トップレベルコンテキスト* と呼ばれるRubyのインタプリタが作成したオブジェクトの内部となる。  

### クラス定義とself

クラス、モジュール定義の内側ではselfはクラス、モジュールそのものになる。  

### Refinements

2.1で学んだオープンクラスでは変更がグローバルに及んでしまう。  
Refinementsはそれに対する解決策となる。  
~~~
module StringExtensions
  refine String do
    def to_alphanumeric
      gsub(/[^\w\s/,'')
    end
  end
end
~~~

このメソッドはusingというキーワードを使うことで有効になり、そのスコープ内のみで使用可能となる。


