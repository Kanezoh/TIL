第６章　リスト

# リストの構造

リストは関数型プログラミングにとって最も重要なデータ構造、リストの分解、構築は非常に重要。  
リストを分解する時の主な要素はhead,tail,終端[]の３つ。  
headは単にリストの先端の要素。  

~~~
head [1,2,3] => 1
head[[1,2],[3,4],[5,6]] => [1,2]
~~~  
tailはheadの後にある残りの要素を示す。  
  
~~~
tail [1,2,3] => [2,3]

tail [3] => []
~~~  

要素が１つだけの要素の終端は[],[]は単なる空のリストを示す。空のリストはhead,tailを持たない特殊なリストになる。  

# リストの構築

リストの構築に必要なのは１つの関数と*コンス*と呼ばれる中間演算子のみ。  
~~~
1:[] => [1]
~~~  

Haskellの全てのリストは内部では一連のコンシング演算、[...]という表記は単なるシンタックスシュガー。  
~~~
1:2:3:4:[] => [1,2,3,4]

(1,2):(3,4):(5,6):[] => [[1,2],[3,4],[5,6]]
~~~  
ここで恐ろしい事実を１つ...  
*ここまで見てきた文字列自体が(二重引用符ではなく単一引用符で表された)文字からなるリストである。*  
~~~
['a','b','a'] => "aba"

'a':'b':'a':[] => "aba"
~~~  

ちなみに、リストは同じ方でなければならないルールがあるので、二重引用符で括られた文字をコンスすることはできない。  
これはシンタックスシュガーによるコーティングを外してみるとよくわかる。  

~~~  
"a":"ba" => error!
['a']:['b','a'] => シンタックスシュガーの層を１つ取り除いた形
'a':[]:'b':'a':[] => 完全に取り除いた形
~~~  
２つのリストを結合したい場合は++を使えばよい。以前は文字列を++で結合していたが、あれは文字列のリストを結合しているという意味だったのだ。  
~~~
"a" ++ "ba" => "aba"
[1] ++ [2,3,4] => [1,2,3,4]
~~~  

リストで再帰関数を作るのにコンシングはかなり重要な概念、覚えよう！ 

## 遅延評価

リストはめっちゃ役に立つのでいろんな生成方法がある。  
~~~
[1 .. 10] => [1,2,3・・・9,10]

[1,3 .. 10] => [1,3,5,7,9] ステップ値を足して奇数を生成

[1,1.5 .. 5] => [1.0,1.5,2.0,2.5・・・4.5,5.0] 0.5ずつ足していく

[1,0 .. -10] => [1,0,-1,-2・・・-9,-10]
~~~  

便利だけど~~~[1 .. ]~~~みたいなことをしたら上限値が存在しない、つまり終わらないリストになるので注意。  
でも、  
~~~
simple x = x
longList = [1 .. ]
stillLongList = simple longList
~~~  

このコードは普通にコンパイルできてしまう(ええ...)、これが*遅延評価*だ。
必要になる時まで計算されない、これにはメリットとデメリットがあり、  
メリット: 無限の長さのリストなど面白い構造のリストを定義できる  
デメリット: 明白さに欠ける  

## リストの関数

### !!関数

引数に数字を受け取り、受け取った数値の位置にあるリストの要素を返す関数。  
終端を超える場合はエラー。  

~~~ 
[1,2,3] !! 0 => 1

"puppies" !! 4 => 'i'

[1 .. 10] !! 11 => Error!
~~~  

中間演算子を使えば前置演算子のようにも使える。  
~~~
(!!) [1,2,3] 0 => 1
~~~  

部分適用と合わせた便利な使用例  
~~~
paExample = (!!) dog
paExample 2 => 'g'

paExample2 = ("dog" !! )
paExample2 2 => 'g'
~~~  

paExample2のように二項演算子で部分適用を使うには式を使うには丸括弧で囲う、これを*セクション*と呼ぶ。  
右オペランドだけなら左を、左オペランドだけなら右オペランドを待機する、すごい。  
~~~
paExample3 =  (!! 2)
paExample3 "dog" => 'g'
~~~  

### length関数
まあ言わなくてもわかるよね。  
~~~ length [1 .. 20] => 20
~~~  

### reverse関数
これも言わずもがな。  
~~~
reverse [1,2,3] => [3,2,1]
~~~  

### elem関数
引数として値とリストを受け取り、その値がリストに含まれているかどうかをチェック。  
~~~
elem 13 [0,13 .. 100] =>  True
~~~  
バッククオートで囲うと中間演算子になってくれる。  
~~~  
respond phrase = if '!' `elem` phrase
                 then "wow!"
                 else "uh..ok"
~~~  

### take関数、drop関数

takeは引数として数字、リストを受け取ってその数値分だけリストを取り出して返す。  
~~~
take 5 [2,4 .. 100] => [2,4,6,8,10]

--数値がリストの終端を超えてもできるだけ仕事をする男。
take 100000000 [1] => [1]
~~~  

dropはリストの先頭から指定された個数の要素を削除する。  
~~~
drop 2 [1,2,3,4,5] => [3,4,5]
~~~  

### zip関数
２つのリストを組み合わせてタプルのペアを作成する。  
~~~
zip [1,2,3] [2,4,6] => [(1,2),(2,4),(3,6)]

--どっちかの要素がカラになった時点で終了
zip "dog" "rabbit" => [('d','r'),('o','a'),('g','b')]
~~~  

### cycle関数

与えられたリストを永遠に繰り返す謎の関数、遅延評価を使って無限のリストを作る。  

~~~
ones n = take n (cycle [1])
~~~  

一見、何に役に立つのか分からないが、リストの要素をグループ化するのにかなり役立つらしい。  
例えば、ファイルのリストを分割してn個のサーバに割り振りたいと言った場合、  

~~~  
assignToGroups n aList = zip groups aList
  where groups = cycle [1..n]

assignToGroups 3 ["file1.txt","file2.txt","file3.txt","file4.txt","file5.txt","file6.txt","file7.txt"]

=> [(1,"file1.txt"),(2,"file2.txt"),(3,"file3.txt"),(1,"file4.txt"),(2,"file5.txt"),(3,"file6.txt"),(1,"file7.txt")]
~~~  

リストの関数は全て標準モジュールPreludeに入ってるらしい。  


