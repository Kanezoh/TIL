第６章　リスト

# リストの構造

リストは関数型プログラミングにとって最も重要なデータ構造、リストの分解、構築は非常に重要。  
リストを分解する時の主な要素はhead,tail,終端[]の３つ。  
headは単にリストの先端の要素。  

~~~
head [1,2,3] => 1
head[[1,2],[3,4],[5,6]] => [1,2]
~~~  
tailはheadの後にある残りの要素を示す。  
  
~~~
tail [1,2,3] => [2,3]

tail [3] => []
~~~  

要素が１つだけの要素の終端は[],[]は単なる空のリストを示す。空のリストはhead,tailを持たない特殊なリストになる。  

# リストの構築

リストの構築に必要なのは１つの関数と*コンス*と呼ばれる中間演算子のみ。  
~~~
1:[] => [1]
~~~  

Haskellの全てのリストは内部では一連のコンシング演算、[...]という表記は単なるシンタックスシュガー。  
~~~
1:2:3:4:[] => [1,2,3,4]

(1,2):(3,4):(5,6):[] => [[1,2],[3,4],[5,6]]
~~~  
ここで恐ろしい事実を１つ...  
*ここまで見てきた文字列自体が(二重引用符ではなく単一引用符で表された)文字からなるリストである。*  
~~~
['a','b','a'] => "aba"

'a':'b':'a':[] => "aba"
~~~  

ちなみに、リストは同じ方でなければならないルールがあるので、二重引用符で括られた文字をコンスすることはできない。  
これはシンタックスシュガーによるコーティングを外してみるとよくわかる。  

~~~  
"a":"ba" => error!
['a']:['b','a'] => シンタックスシュガーの層を１つ取り除いた形
'a':[]:'b':'a':[] => 完全に取り除いた形
~~~  
２つのリストを結合したい場合は++を使えばよい。以前は文字列を++で結合していたが、あれは文字列のリストを結合しているという意味だったのだ。  
~~~
"a" ++ "ba" => "aba"
[1] ++ [2,3,4] => [1,2,3,4]
~~~  

リストで再帰関数を作るのにコンシングはかなり重要な概念、覚えよう！ 

## 遅延評価

リストはめっちゃ役に立つのでいろんな生成方法がある。  
~~~
[1 .. 10] => [1,2,3・・・9,10]

[1,3 .. 10] => [1,3,5,7,9] ステップ値を足して奇数を生成

[1,1.5 .. 5] => [1.0,1.5,2.0,2.5・・・4.5,5.0] 0.5ずつ足していく

[1,0 .. -10] => [1,0,-1,-2・・・-9,-10]
~~~  

便利だけど~~~[1 .. ]~~~みたいなことをしたら上限値が存在しない、つまり終わらないリストになるので注意。  
でも、  
~~~
simple x = x
longList = [1 .. ]
stillLongList = simple longList
~~~  

このコードは普通にコンパイルできてしまう(ええ...)、これが*遅延評価*だ。
必要になる時まで計算されない、これにはメリットとデメリットがあり、  
メリット: 無限の長さのリストなど面白い構造のリストを定義できる  
デメリット: 明白さに欠ける  
 
