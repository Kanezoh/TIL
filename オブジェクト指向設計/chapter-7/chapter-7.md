# 第７章　モジュールでロールの振る舞いを共有する

### 7-1 ロール（役割）を理解する
もともと無関係なオブジェクトが共通のロールを担うことがある。これは継承の親と子のような関係より明白でない。  

#### ロールを見つける
第５章のダックタイピングで登場したpreparerはロールの一種。  
オブジェクト指向言語にはクラスとは無関係に、メソッドのグループに名前を付けて定義する方法が備わっている、Rubyの場合はこれがモジュールであり、クラスにmixinして使う。つまり、これを使って共通のロールを複数クラスに共有させることができる。  
モジュールによってオブジェクトが応答できるメッセージは  
- 自身が実装するメッセージ
- 自身より上の階層の全てのオブジェクトで実装されるメッセージ
- 自身に追加されるモジュールで実装されるメッセージ
- 自信より上の階層のオブジェクトに追加されるモジュールで実装されるメッセージ   
と、かなり膨大なためしっかりと管理しなければならない。  
#### 責任の管理
例：レンタル工具店、工具がレンタルできるかどうかを調べるが、レンタルから戻ってきた工具はその工具に応じてメンテナンス期間が必要、それを踏まえてレンタルできるかどうかを判断する。  
扱う工具とメンテナンス期間  
スパナ（１日）、ハンマー（３日）、レンチ（４日）  

これらのレンタル予定を管理するクラスをScheduleクラスと置き、次の３つのインターフェースを持つとする。
~~~
scheduled?(target,starting,ending)
add(target,starting,ending)
remove(target,starting,ending)
~~~
このコードは現在借りられているか、は判断できるが、メンテナンス期間を考慮していないため”現在借りられるか”が分からない。
これを解決するため、メンテナンス期間をScheduleクラスに持たせてみる。  

図7-1

この例ではどの値を使えば良いかを知るためにクラスを確認している。どのクラスにどの値を用いるかの情報はScheduleが持つべきではない。  
#### 不必要な依存関係を取り除く
５章の例を見ればわかるように、クラスを確認するような例ではダックタイピングを使用するのが良い。  
次の例では工具をtargetオブジェクトとして、lead_daysの実装を求めた。Scheduleクラスがメンテナンス期間を得る際にはtargetにメッセージを送ることになる。

図7-2
#### オブジェクト自身に自身を語らせる  
しかし、この手法でもまだ改善点がある。オブジェクトは自身を管理すべき、という原則を考えると、targetオブジェクトがレンタル可能かを調べるときに、Scheduleクラスに対して問い合わせている。targetがレンタル可能かどうかはtargetに直接聞くべきだ。  
#### 具体的なコードを書く

図7-3
これでtarget が直接自身のレンタル可能性について応答できるようになった。
これをコードに起こすと  
~~~
class Schedule
  def scheduled?(schedulable,start_date,end_date)
    puts "This is #{schedulable.class}"+
         "is not schedulabled\n"
         "between #{start_date} and #{end_date}"
    false
  end
end
~~~

プロダクト用コードなのでお粗末さはご容赦を。次に具体的な工具クラスを見ていく  

~~~
class Spanner
  attr_reader :schedule,:size

  def initialize(args={})
    @schedule=args[:schedule] || Schedule.new
  end

  def schedulable?(start_date,end_date)
    !scheduled?(start_date - lead_days,end_date)
  end

  def scheduled?(start_date,end_date)
    schedule.scheduled?(self,start_date,end_date)
  end

  def lead_days
    1
  end
end
~~~

#### 抽象を抽出する
Spannerクラス以外にもこのロール（schedulable）を担うメソッドがいるので、必要なメソッド群をモジュール化する。
~~~
module Schedulable
  attr_writer :schedule

  def schedule
    @schedule ||= ::Schedule.new
  end

  def shedulable?(start_date,end_date)
    !scheduled?(start_date-lead_days,end_date)
  end

  def scheduled?(start_date,end_date)
    schedule.scheduled?(self,start_date,end_date)
  end

  def lead_days
    0
  end
end
~~~

図7-2では開始オブジェクトはScheduleに依存していた。これでは、Scheduleの知識が必要な箇所が散らかって収集がつかなくなる。  
図7-3ではこの依存をtargetに移したことで、依存が散らばる範囲は狭まった。  
そして今回のコードでScheduleへの依存は完全にmoduleの中へと隔離された。  
lead_daysについてはインクルードするクラス側で好きにオーバーライドすればいい、とりあえず初期値として有効な値を設定している。  

### 7-2 継承可能なコードを書く
アンチパターン１  
オブジェクトがtypeやcategoryという変数名を使い、どんなメッセージをselfに送るか決めているパターン  
→継承を使ってサブクラスを定義してそっちでやる  

アンチパターン２  
メッセージを受け取るオブジェクトのクラスを確認してからどのメッセージを送るかをオブジェクトが決めているパターン  
→ダックタイプを利用する  

#### 抽象に固執する
抽象スーパークラス内のコードを使わないサブクラスがあってはいけない、モジュールのコードを一部しか使わないオブジェクトがあってもいけない  
サブクラスの一部でしか使わないようなコードは抽象クラスにおいてはいけない。  
つまり、一部のサブクラスで実装を必須にするためにraise NotImplemetedErrorを出すようであればこの間違いが起きていると言える。  
#### 契約を守る
サブクラスではスーパークラスと同じメソッドを受け取り、それに応答することを求められる。親子が置換可能であり続けなければならない。  
他のオブジェクトに自身の型を識別させて自身の扱いを決めさせるようなことはあってはいけない。  

#### テンプレートメソッドパターンを使う
抽象コードでアルゴリズムを定義し、抽象を継承する具象でテンプレート化されたメソッドをオーバーライドすることで特化を行うのが正しい手法  

#### 前もって疎結合にする
継承する側でsuperを呼び出すようなコードは避けるべき。代わりにフックメッセージを使う。そうすれば抽象クラスのアルゴリズムを知っている責任から逃れながらアルゴリズムに加わることができる。

#### 階層構造は浅くする
フックメソッドは階層が隣接する場合にしか使えないので階層は出来るだけ浅くするべき。また、階層が深いと単純に構造を把握しにくくなる。メッセージの探索パスも長くなる。出来るだけ浅く

### まとめ

#### 共通のロールをモジュールでまとめよう
#### モジュールでもテンプレートメソッドパターンを用いてincludeするクラス側で特化させよう
