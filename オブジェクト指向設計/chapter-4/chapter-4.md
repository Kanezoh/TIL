# 第４章 柔軟なインターフェースをつくる

### 4-1 インターフェースを理解する

クラス内のメソッドには外部に晒すべきものと晒すべきでないものがある。  
その晒されたメソッドによって構成されるのがそのクラスの**インターフェース**
クラスのメソッドのうち、他のオブジェクトから使われるものをそのクラスのパブリックインターフェースと定義する。
つまり、クラス内のメソッドの**どれ**を**どのように**外部に晒すかを扱う。  

### 4-2 インターフェースを定義する

#### パブリックインターフェース（外部に晒されるメソッドの集合）の特性  
- クラスの主要な責任を明らかにする
- 外部から実行することが想定される
- 気まぐれに変更されない
- 他者がそこに依存しても安全
- テストで完全に文書化されている  

#### プライベートインターフェース（パブリックでないインターフェース）の特性  
- 実装の詳細に関わる
- 他のオブジェクトから送られてくることは想定されていない
- どんな理由でも変更されうる
- 他者がそこに依存するのは危険
- テストでは言及さえされないこともある  

#### 責任、依存関係、インターフェース

２章で単一の責任を持つクラスについて扱った。クラスがすること(＝クラスの具体的な責任)は自ずとその目的を果たすものになる。
とすると、この責任とクラスのパブリックメソッドの間には対応関係がある。  
３章ではクラスは自身より変更されにくいものに依存すべきだと学んだ。クラス内のパブリックな部分は安定しているが、プライベートな部分は変更されやすい。この区別はクラスの使用者に「どのメソッドになら安全に依存できるか」の情報を与えている。  

### 4-3 パブリックインターフェースを見つける  

####シーケンス図を使う
例：工具店
客が自分が欲しいものとその数量をスタッフに伝えて注文したい、という要件を想像する。
例えば、ドライバーが欲しければ店が扱っているドライバーの種類、在庫が欲しい数量に足りるかを調べ、最適なドライバーを教えてくれる。  
これらから設計をしようとすると、まず客、店番、倉庫スタッフクラスを作ることを思いつく。これらはデータと振る舞いを持つ名詞だからだ。これらをドメインオブジェクトと呼ぶことにする。  
しかし、ドメインオブジェクトに囚われ過ぎると無理な設計になりがち。重要なのはオブジェクト間でどのような**メッセージ**が交わされるか  

ここでは、設計の手法として**シーケンス図**を使用する。（UMLというオブジェクト指向のモデリング言語の一種）
この図では客が店番にorderメッセージを送り、レスポンスを得る。
![図１](https://github.com/Kanezoh/TIL/blob/master/images/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88/image4-1.jpg)

さて、ここではStaffクラスが注文に関わる全ての処理を行なっている。店の取扱商品から要求されるitemの一覧を返し、さらにその数量が注文数に足るかも調べている。ここでの疑問は「Staffが在庫を調べる責任まで追うべきだろうか？」。客がsuitable_itemsを送るのは理にかなっている。  
しかし、接客のためのスタッフが在庫を調べるのはどうか。とりあえず倉庫スタッフを作ってみる。
![図２](https://github.com/Kanezoh/TIL/blob/master/images/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88/image4-2.jpg)

図1ではCustomerは
- アイテムの一覧が欲しい
- suitable_itemsに応答するオブジェクトがある  

図2では
- アイテムの一覧が欲しい
- suitable_itemsに応答するオブジェクトがある
- 適切なアイテムを見つけるには適切な数量を見つけるのも含まれる
- enough_numに応答する他のオブジェクトがある

ことを知っている。  
この改善案ではCustomerが他のオブジェクトが**どのように**望むものを準備するかまで知ってしまっている。  
これではCustomerが倉庫に入り込んで倉庫スタッフに数量を確認しているようなもの。他が追うべき責任まで負ってしまっている。  

#### 「どのように」を伝えるのでなく「何を」を頼む  

ここでは設計の問題はさておき、「どのように」でなく「何を」を基準にすることを考える。  
例として、StaffがRepairmanに客に商品を出す前にしっかりと商品が整備されているかを確認することを想定する。
![図３](https://github.com/Kanezoh/TIL/blob/master/images/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88/image4-3.jpg)

この例では  
- Staffのパブリックインターフェースはitemsを含む
- Repairmanのパブリックインターフェースはclean_item,polish_item,pack_itemを含む
- Staffは上のメソッドらに応答できるオブジェクトを持ち続ける

ことになっている。StaffはRepairmanが行うことについて詳細をいくつも知っている。つまり、整備の手順に新しいものが追加されたらStaffにも変更が及ぶ。代案を考えよう。  
![図４](https://github.com/Kanezoh/TIL/blob/master/images/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88/image4-4.jpg)

この例では  
- Staffのパブリックインターフェースはitemsを含む
- Repairmanのパブリックインターフェースはprepare_itemを含む
- Staffはprepare_itemに応答するオブジェクトを持ち続けることを想定する  

これで、「どのように」を知る責任はRepairmanに渡された。２つのオブジェクト間の会話が「どのように」から「何を」に変わったことで、Repairmanのパブリックインターフェースが一段と小さくなった。Repairmanが晒しているメソッドはprepare_itemのみ。他のところから依存されるメソッドが少ないことは、変更による他のオブジェクトへの変化も小さいことを意味する。  
より少ない知識で同じことを行えればコードの柔軟性、メンテナンス性は向上します。

#### コンテキストの独立を模索する  

Staffが他のオブジェクトについて知っていることによってStaffの**コンテキスト**が形成される。単純なコンテキストを持つオブジェクトは、再利用が容易で、他のオブジェクトに多くを求めない。また、多くのオブジェクトと共同作業が可能。  
Staffが求めるのは「準備されていること」。それにアイテムが必要だということを判断することはRepairmanの責任
![図５](https://github.com/Kanezoh/TIL/blob/master/images/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88/image4-5.jpg)

ここでは  
- Staffのパブリックインターフェースはitemsを含む
- Repairmanのパブリックインターフェースはprepare_itemを含む
- Staffはprepare_itemの応答するインターフェースを持ち続ける
- Repairmanはprepare_itemと共に渡された引数がitemsに応答することを想定する  


#### 他のオブジェクトを信頼する

図４のコードは手続き的だ。StaffがメインプログラムでRepairmanは呼び出し可能な関数のようにしか見えない。  
図５はオブジェクト指向的だ。Staffのコンテキストは削減され、Repairmanのパブリックインターフェースも小さくなった。  
図６はよりオブジェクト指向的だ。Staffは自身がRepairmanを持っていることを知らない。ただprepare_itemsに応答するオブジェクトを保持していることを知っているのみだ。

### 一番良い面（インターフェース）を表に出すコードを書く  

#### 明示的なインターフェースを作る
- 明示的にパブリックインターフェースだと特定できる
- 「どのように」よりも「何を」になっている
- 名前は考えられる限り、変わりうるものである
- オプション引数としてハッシュをとる

Rubyのキーワード、public,protected,privateは２つの用途で用いられる。
- 1. どのメソッドが安定でどのメソッドが不安定か
- 2. アプリケーションの他のところからどれだけ見えるかを制御する

しかし、キーワードは後からでも変えられるため、完全なアクセスの制限にならない。  
ただ、
- 将来のプログラマーよりも今の自分の方が良い情報を持っていると信じている
- 今の自分が不安定だと思うメソッドを将来のプログラマーが不用意に使うことを防ごうと思っている

このように、キーワードは不安定なものなので慣習的にメソッドの先頭にアンダーバーを付けてプライベートな部分を示していることが多い。

#### 他のパブリックインターフェースに敬意を払う

他のクラスのパブリックインターフェースは外部に晒して良い、比較的安定したものとして提供されている。それを念頭に、出来るだけパブリックインターフェースのみを利用すべき。不安定なプライベートメソッドに依存することはリスクが高い。  

#### コンテキストを最小限に  

パブリックインターフェースを作る際は、そのメソッドが他者に要求するコンテキストを最小限にすべき。  
メッセージの送り手が実装がどのようになっているか知ることなく、求めているものを得られるようにすべき。

### デメテルの法則

デメテルの法則：オブジェクトを疎結合にするためのコーディング規則の集まり  

#### デメテルを定義する
デメテルはメッセージを送ることのできるオブジェクトの数を制限する。つまり、**３つ目のオブジェクトにメッセージを送る際に、異なる型の２つ目のオブジェクトを経由する**ことを禁じる。  
以下の例はメッセージチェーンと呼ばれ、俗に列車事故とも呼ばれる。
- customer.order.menu.number
- customer.order.menu.make
- hash.keys.sort.join(',')

#### 違反することの影響

第二章でコードはTRUEにすべきだと学んだ。法則違反はコードをTRUEから遠ざける。問題点は
- 途中のメッセージを変更するとメソッドそのものが壊れる可能性がある
- クラスのコンテキストが膨大になる
- 汚いコードが自己増殖していく  

もちろん遠くの属性を取得するのに中間のオブジェクトを経由するのが最適解なこともあるので、要はケースバイケース。
ただ、属性を変更しようとして呼び出しているなら除去すべき。これは属性の取得でなく、「振る舞い」の実行に当たる。  
遠くの振る舞いを実行するのに多くのオブジェクトを経由するのは大きなリスクとなる。  
ちなみに３つ目の例は何も問題ない。
- hash.keys => Enumerable
- hash.keys.sort => Enumerable
- hash.keys.sort.join => String  

最後にStringと型が変わっているが、複数のStringからなるEnumerableだと思えば問題ない。

#### 違反を回避する

メッセージを**委譲する**のが１つの手段。これはラッパーメソッドを介して他のオブジェクトにメッセージを送ることで実現できる。  


### まとめ

#### メソッドの安定性の違いを意識する
#### コンテキストを出来るだけ少なく、他のオブジェクトを信頼する
#### デメテルの法則を意識、かといって囚われ過ぎるのも危険
