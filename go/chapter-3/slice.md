# 参照型

参照型は3種類ある。  
- スライス(slice)
- マップ(map)
- チャネル(chanel)  

## make
参照型の生成には組み込み関数のmakeを使用する。  

## スライス
もっとも利用頻度が高い可変長配列を表現する型。  
~~~
// int型のスライス
var s []int  
~~~  

次のコマンドは要素数と容量が10のint型スライスを生成する。  
~~~
s := make([]int, 10)
fmt.Println(s)
=> [0,0,0,0,0,0,0,0,0,0]
~~~  
スライスと配列は全く違う構造だが、似たような挙動をする。  
~~~  
var a [10]int
fmt.Println(a)
=> [0,0,0,0,0,0,0,0,0,0]
~~~  

### len
組み込み関数のlenを使ってスライスの現在の要素数を調べることができる。(配列でも使用可能)  

~~~
s := make([]int, 8)
len(s) // == 8
~~~  

### cap
スライスは要素数の他にも容量という属性を持つ。capはスライスの容量を調べるための関数である。  
~~~  
s1 := make([]int, 5)
fmt.Println(len(s1)) => "5"
fmt.Println(cap(s1)) => "5"

s2 := make([]int, 5, 10)
fmt.Println(len(s2)) => "5"
fmt.Println(cap(s2)) => "10"
~~~  
3番目の引数を指定すると容量を指定することができる。(3番目を指定してない場合は容量と要素数は2番目の引数の値となる)  

#### 容量とは
要素数5,容量が10のスライスの場合、参照・代入できるのは0~4まで。しかし内部では10個分の領域が確保されている。  
これはスライスを拡張する際に容量の値までは新たな領域を確保しなくて良いというメリットがある。  

#### スライス生成リテラル
makeを使用せずにリテラルを使用する方法もある。  
~~~  
s := []int{1,2,3,4,5}
len(s) => 5
cap(s) => 5
~~~  
#### 簡易スライス式

~~~
a := [5]int{1,2,3,4,5} // 配列の宣言
s := a[0:2] // [n:m]の形式の範囲パラメータ
fmt.Println(s) => "[1,2]"
~~~  
[n:m]の形式で配列型かスライスに範囲パラメータを渡すことでnからm-1までの範囲を切り出してスライスにすることができる。  

##### 文字列と簡易スライス式
~~~
s := "ABCDE"[1:3] => "BC"
~~~  
文字列を簡易スライス式で切り出すことができる。ただし、この操作は文字単位ではなくバイト単位で切り出しているため注意が必要。  
~~~
s := "あいうえお"[3:9] => "いう"
~~~  
あいうえおはUTFエンコードで3バイトを要し、バイト列で切り出すためこうなる。  
ASCII文字のみなら便利だがそれ以外のエンコードなら注意が必要。  

### append

スライスを拡張するための関数。Goにおける配列は[10]intと[11]intでは全く別物となる。  
スライスは可変長のため拡張することができる。  
~~~  
s := []int{1,2,3}
s = append(s, 4) => [1,2,3,4]
s = append(s, 5, 6, 7) => [1,2,3,4,5,6,7]
~~~  

appendを行う場合は変数の代入を伴わないとエラーになる。スライスを拡張したい場合に```append(s,2)```のように単体で書いてもエラーになる。  
スライスに別のスライスの要素を追加することもできる。  
~~~  
s0 := []int{1,2,3}
s1 := []int{4,5,6}
s2 := append(s0, s1) => [1,2,3,4,5,6]
~~~  

##### appendと容量
~~~
// 要素数0, 容量0のスライス
s := make([]int, 0, 0)
fmt.Printf("(A) len=%d, cap=%d\n", len(s), cap(s))
s = sppend(s, 1)
fmt.Printf("(B) len=%d, cap=%d\n", len(s), cap(s))
s = appebd(s, []int{2,3,4})
fmt.Printf("(C) len=%d, cap=%d\n", len(s), cap(s))
s = append(s, 5)
fmt.Printf("(D) len=%d, cap=%d\n", len(s), cap(s))
s = append(s, 6, 7, 8, 9)
fmt.Printf("(E) len=%d, cap=%d\n", len(s), cap(s))

=>
(A) len=0, cap=0
(B) len=1, cap=1
(C) len=4, cap=4
(D) len=5, cap=8
(E) len=9, cap=16
~~~  
要素の追加に伴ってGoランタイムがスライスの容量を倍増させていることがわかる。  
Goのランタイムによるので倍増するかはともかく容量は要素数の増加に伴って増加していく。  

### copy

スライスにスライスの値を一括でコピーするための変数。1番目の引数に指定したスライスをコピー先として
2番目の引数に指定したスライスの内容を、コピー先のスライスの先頭から塗り潰すようにコピーする。  

~~~
s1 := []int{1,2,3,4,5}
s2 := []int{10,11}
n := copy(s1, s2) => n == 2, s1 == [10, 11, 3, 4, 5]
~~~  
copy関数は返り値としてコピーに成功した要素数を返す。  

コピー元のスライスの要素数がコピー先より大きくても問題はない。  
~~~
s1 := []int{1,2,3,4,5}
s2 := []int{10,11,12,13,14,15,16}
n := copy(s1, s2) n == 5, s1 == [10,11,12,13,14]
~~~  




