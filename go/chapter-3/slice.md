# 参照型

参照型は3種類ある。  
- スライス(slice)
- マップ(map)
- チャネル(chanel)  

## make
参照型の生成には組み込み関数のmakeを使用する。  

## スライス
もっとも利用頻度が高い可変長配列を表現する型。  
~~~
// int型のスライス
var s []int  
~~~  

次のコマンドは要素数と容量が10のint型スライスを生成する。  
~~~
s := make([]int, 10)
fmt.Println(s)
=> [0,0,0,0,0,0,0,0,0,0]
~~~  
スライスと配列は全く違う構造だが、似たような挙動をする。  
~~~  
var a [10]int
fmt.Println(a)
=> [0,0,0,0,0,0,0,0,0,0]
~~~  

### len
組み込み関数のlenを使ってスライスの現在の要素数を調べることができる。(配列でも使用可能)  

~~~
s := make([]int, 8)
len(s) // == 8
~~~  

### cap
スライスは要素数の他にも容量という属性を持つ。capはスライスの容量を調べるための関数である。  
~~~  
s1 := make([]int, 5)
fmt.Println(len(s1)) => "5"
fmt.Println(cap(s1)) => "5"

s2 := make([]int, 5, 10)
fmt.Println(len(s2)) => "5"
fmt.Println(cap(s2)) => "10"
~~~  
3番目の引数を指定すると容量を指定することができる。(3番目を指定してない場合は容量と要素数は2番目の引数の値となる)  

#### 容量とは
要素数5,容量が10のスライスの場合、参照・代入できるのは0~4まで。しかし内部では10個分の領域が確保されている。  
これはスライスを拡張する際に容量の値までは新たな領域を確保しなくて良いというメリットがある。  

#### スライス生成リテラル
makeを使用せずにリテラルを使用する方法もある。  
~~~  
s := []int{1,2,3,4,5}
len(s) => 5
cap(s) => 5
~~~  
#### 簡易スライス式

~~~
a := [5]int{1,2,3,4,5} // 配列の宣言
s := a[0:2] // [n:m]の形式の範囲パラメータ
fmt.Println(s) => "[1,2]"
~~~  
[n:m]の形式で配列型かスライスに範囲パラメータを渡すことでnからm-1までの範囲を切り出してスライスにすることができる。  

##### 文字列と簡易スライス式
~~~
s := "ABCDE"[1:3] => "BC"
~~~  
文字列を簡易スライス式で切り出すことができる。ただし、この操作は文字単位ではなくバイト単位で切り出しているため注意が必要。  
~~~
s := "あいうえお"[3:9] => "いう"
~~~  
あいうえおはUTFエンコードで3バイトを要し、バイト列で切り出すためこうなる。  
ASCII文字のみなら便利だがそれ以外のエンコードなら注意が必要。  

### append

スライスを拡張するための関数。Goにおける配列は[10]intと[11]intでは全く別物となる。  
スライスは可変長のため拡張することができる。  
~~~  
s := []int{1,2,3}
s = append(s, 4) => [1,2,3,4]
s = append(s, 5, 6, 7) => [1,2,3,4,5,6,7]
~~~  

appendを行う場合は変数の代入を伴わないとエラーになる。スライスを拡張したい場合に```append(s,2)```のように単体で書いてもエラーになる。  
スライスに別のスライスの要素を追加することもできる。  
~~~  
s0 := []int{1,2,3}
s1 := []int{4,5,6}
s2 := append(s0, s1) => [1,2,3,4,5,6]
~~~  

##### appendと容量
~~~
// 要素数0, 容量0のスライス
s := make([]int, 0, 0)
fmt.Printf("(A) len=%d, cap=%d\n", len(s), cap(s))
s = sppend(s, 1)
fmt.Printf("(B) len=%d, cap=%d\n", len(s), cap(s))
s = appebd(s, []int{2,3,4})
fmt.Printf("(C) len=%d, cap=%d\n", len(s), cap(s))
s = append(s, 5)
fmt.Printf("(D) len=%d, cap=%d\n", len(s), cap(s))
s = append(s, 6, 7, 8, 9)
fmt.Printf("(E) len=%d, cap=%d\n", len(s), cap(s))

=>
(A) len=0, cap=0
(B) len=1, cap=1
(C) len=4, cap=4
(D) len=5, cap=8
(E) len=9, cap=16
~~~  
要素の追加に伴ってGoランタイムがスライスの容量を倍増させていることがわかる。  
Goのランタイムによるので倍増するかはともかく容量は要素数の増加に伴って増加していく。  

### copy

スライスにスライスの値を一括でコピーするための変数。1番目の引数に指定したスライスをコピー先として
2番目の引数に指定したスライスの内容を、コピー先のスライスの先頭から塗り潰すようにコピーする。  

~~~
s1 := []int{1,2,3,4,5}
s2 := []int{10,11}
n := copy(s1, s2) => n == 2, s1 == [10, 11, 3, 4, 5]
~~~  
copy関数は返り値としてコピーに成功した要素数を返す。  

コピー元のスライスの要素数がコピー先より大きくても問題はない。  
~~~
s1 := []int{1,2,3,4,5}
s2 := []int{10,11,12,13,14,15,16}
n := copy(s1, s2) n == 5, s1 == [10,11,12,13,14]
~~~  

### 完全スライス式
スライス式には3つの引数をとる完全スライス式がある。  
簡易スライス式との違いはmaxの指定によってスライスの容量をコントロールできることだ。  
```a[low, :high, :max]```  
 ~~~
 a := [10]int{1,2,3,4,5,6,7,8,9,10}

 s1 := a[2:4] => s1 == [3,4]
len(s1) => 2
cap(s1) => 8
// 簡易スライス式で生成したスライスの容量は元の[10]int型の参照していない範囲

s2 := a[2:4:4] => s2 == [3,4]
len(s3) => 2
cap(s3) => 2
~~~  
完全スライス式を使った場合のスライスの容量は(max-low)の値になる。  

### スライスとfor
~~~
s := string{"Apple", "Banana", "Cherry"}

for i,v := range s {
  fmt.Printf("[%d] => %s\n", i, v)
}
[0] => Apple
[1] => Banana
[2] => Cherry
~~~  

### スライスと可変長引数
Printfのように任意の個数の引数を取ることができる関数はスライスで実装されている。  
Printfでは1番目の引数にフォーマット文字列、2番目以降の引数はinterface型のスライスaでまとめられる。  
~~~
func Printf(format string, a...interface{}) (n, int, err, error)
~~~  
このように関数の定義に可変長引数を使えば任意個の引数を取る関数を定義することができる。  
~~~  
func sum(s ...int) int {
  n := 0
  for _, v := range s{
    n += v
  }
  return n
}
~~~  

### 参照型としてのスライス

~~~
func pow(a [3]int){
  for i,v := range a {
    a[i] = v * v
  }
  return
}

func main(){
  a := [3]int{1,2,3}
  pow(a)
  fmt.Println(a) => "[1,2,3]"
}
~~~  

配列を引数にとった関数の呼び出しでは引数は値渡しで行われるため、メイン関数内のaと関数pow内のものは別である。  
つまり2乗したところでそれは反映されない。スライスは参照渡しで行われるため、出力は異なる。  
~~~
func pow(a []int){
  for i,v := range a{
    a[i] = v * v
  }
  return
}

func main(){
  a := []int{1,2,3}
  pow(a)
  fmt.Println(a) => "[1,4,9]"
}
~~~  
スライス型は参照渡しのためメイン関数内のスライスとpow関数のスライスは同じメモリ領域に対する処理になる。  

~~~
var(
  a [3]int
  s []int
)
fmt.Println(a) => "[0,0,0]"
fmt.Println(s === nil) => "true"
~~~  

他にも配列型とスライスにはnilを値として取りうるか、という違いもある。int
