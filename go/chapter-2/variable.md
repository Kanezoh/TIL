# Goの変数

## 変数の基本
### 変数定義いろいろ
int型のx,y,zを定義  

```var x,y,z int```  

int型のx,yとstring型のnameを定義  
~~~
var(
	x,y int
	name string
)
~~~  

宣言と定義を同時に  

```var x int = 1```  

暗黙的に定義(型推論)  

```i := 1 // int型のiを宣言して1を代入```  

### パッケージ変数とローカル変数
~~~
package main

import (
  "fmt"
)

// パッケージ変数(関数定義の外部で宣言された変数)
n := 100

func main(){
  n = n + 1
  fmt.Printf("n=%d\n", n) // => 101
}
~~~  

パッケージ変数は宣言されたパッケージ(今回はmainパッケージ)の中ならどこからでも参照できる。  

### 参照されない変数チェック
参照されていない変数があるとエラーが出る。  
~~~
func main(){
  a := 1
  b := 2
  c := 3

  fmt.Println(a)
}
~~~  
b,cが定義されたが使われていないのでエラーが出る。

## 基本型

### 論理値型

~~~
var b bool
b = true
~~~  

### 数値型
符号付き整数型はサイズによって  
int8, int16, int32, int64  

符号なし整数もサイズによって  
uint8, uint16, uint32, uint64  
が用意されている。これはCの場合は実装によって異なるサイズ数を明確に宣言して
実装依存を無くしている意味がある。しかし実装依存のものもあり  
int, uint, uintptr  
の3つがある。  
ちなみに64ビット実装のintとint64は全く同じだが、厳密な型チェックを行うGoでは
片方の値を片方に代入しようとするとエラーが起きる。

#### 型変換の方法

~~~  
n := 1 //int
b := byte(n) // byte型(byte型はuint8型の別名)
i64 := int64(n) //int64型
u32 := uint32(n) //uint32型  
~~~  

##### 桁あふれ
~~~
b := byte(256) // コンパイルエラー

n := 256
b := byte(n) // => 0になる
~~~  
オーバーフローが発生すると演算結果がラップアラウンドされる。
