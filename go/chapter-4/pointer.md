# ポインタ

ポインタ:「値型」に分類されるデータ構造のメモリ上のアドレスと型の情報

## ポインタの定義
```*int```のように参照・操作する型の前に「*」を置くことで定義できる。  
~~~
var p *int
fmt.Println(p == nil) // => "true"
~~~  

ポインタを定義するための*を重ねて書くことで参照・操作する型がポインタのポインタ型を定義できる。  
```var p **int``` int型のポインタのポインタを参照・操作するためのポインタ型  

### アドレス演算子とデリファレンス
アドレス演算子&を使ってポインタ型を生成することができる。  
~~~
var i int
p := &i
fmt.Printf("%T\n", p) // => "*int"
pp := &p
fmt.Printf("%T\n", pp) // => "**int"
~~~  

ポインタ型から値を参照するには演算子*をポインタ型の変数の前に置くことでポインタ型が指すデータの**デリファレンス**をすることができる。これはポインタが指すメモリのアドレスを経由してデータ本体を参照するための仕組み。  
~~~
var i int
p := &i
i = 5
fmt.Println(*p) // => 5
~~~  

### 文字列型とポインタ
~~~
s := "ABC"
&s // 文字列型のポインタ
s[0] // 文字列型のインデックス参照(byte型)
&s[0] // コンパイルエラー
~~~  

String型のポインタを参照するとエラーになる。  
~~~  
is := [3]int{1,2,3}
ip := & is[1]
*ip = 0
is // == [1,0,3]

fs := []float64{1.1,2.2,3.3}
fp := &fs[2]
*fp = 3.14
fs // == [1.1,2.2,3.14]
~~~  
float64型は普通に参照できる、なぜ？？？  
**Goでは一度生成された文字列は基本的に変更できないように設計している**  

